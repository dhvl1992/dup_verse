import React, { useState, useRef } from 'react';
import * as d3 from 'd3';

export default function TextNetworkViz() {
  const [text, setText] = useState('');
  const [threshold, setThreshold] = useState(0.5);
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState('');
  const svgRef = useRef(null);
  const pipelineRef = useRef(null);

  // Cosine similarity between two vectors
  const cosineSimilarity = (a, b) => {
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  };

  const visualize = async () => {
    if (!text.trim()) return;

    setLoading(true);
    setStatus('Loading embedding model...');

    try {
      // Dynamically import transformers.js
      const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2');

      // Load the model (cached after first load)
      if (!pipelineRef.current) {
        pipelineRef.current = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
      }
      const extractor = pipelineRef.current;

      setStatus('Processing text...');

      // Split into chunks
      const chunks = text
        .split(/[.!?\n]+/)
        .map(s => s.trim())
        .filter(s => s.length > 10);

      if (chunks.length < 2) {
        alert('Need more text! Add at least 2 sentences.');
        setLoading(false);
        return;
      }

      setStatus(`Generating embeddings for ${chunks.length} chunks...`);

      // Generate embeddings for all chunks
      const embeddings = [];
      for (let i = 0; i < chunks.length; i++) {
        setStatus(`Embedding chunk ${i + 1}/${chunks.length}...`);
        const output = await extractor(chunks[i], { pooling: 'mean', normalize: true });
        embeddings.push(Array.from(output.data));
      }

      // Create nodes
      const nodes = chunks.map((chunk, i) => ({
        id: i,
        text: chunk.substring(0, 50) + (chunk.length > 50 ? '...' : ''),
        fullText: chunk,
        embedding: embeddings[i]
      }));

      setStatus('Building network...');

      // Create edges based on cosine similarity
      const links = [];
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const sim = cosineSimilarity(embeddings[i], embeddings[j]);
          if (sim > threshold) {
            links.push({
              source: i,
              target: j,
              value: sim
            });
          }
        }
      }

      // Clear previous
      d3.select(svgRef.current).selectAll('*').remove();

      const width = 900;
      const height = 600;

      const svg = d3.select(svgRef.current)
        .attr('width', width)
        .attr('height', height);

      // Create force simulation
      const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(d => 150 * (1 - d.value)))
        .force('charge', d3.forceManyBody().strength(-400))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(30));

      // Draw links
      const link = svg.append('g')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke', '#4ade80')
        .attr('stroke-opacity', d => d.value * 0.8)
        .attr('stroke-width', d => d.value * 4);

      // Draw nodes
      const node = svg.append('g')
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('r', 10)
        .attr('fill', d => {
          // Color by cluster (simple: hash based on first few chars)
          const hash = d.fullText.substring(0, 3).charCodeAt(0) % 5;
          const colors = ['#fbbf24', '#f97316', '#ec4899', '#8b5cf6', '#06b6d4'];
          return colors[hash];
        })
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .call(drag(simulation));

      // Add labels
      const labels = svg.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .text(d => d.text)
        .attr('font-size', 11)
        .attr('fill', '#e5e7eb')
        .attr('dx', 15)
        .attr('dy', 4)
        .style('pointer-events', 'none');

      // Update positions
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);

        labels
          .attr('x', d => d.x)
          .attr('y', d => d.y);
      });

      // Drag functionality
      function drag(simulation) {
        function dragstarted(event) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          event.subject.fx = event.subject.x;
          event.subject.fy = event.subject.y;
        }

        function dragged(event) {
          event.subject.fx = event.x;
          event.subject.fy = event.y;
        }

        function dragended(event) {
          if (!event.active) simulation.alphaTarget(0);
          event.subject.fx = null;
          event.subject.fy = null;
        }

        return d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended);
      }

      setStatus('Done! âœ¨');
      setTimeout(() => setStatus(''), 2000);

    } catch (error) {
      console.error('Error:', error);
      setStatus('Error: ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="p-6 bg-gray-900 min-h-screen text-white">
      <h1 className="text-3xl font-bold mb-2">ðŸ§  Semantic Network Visualizer</h1>
      <p className="mb-4 text-green-400 text-sm">Using real AI embeddings (runs in browser, 100% free)</p>
      
      <textarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Paste your text, chat history, journal entries, notes, or any content here..."
        className="w-full h-40 p-3 bg-gray-800 border border-gray-700 rounded text-white mb-4 font-mono text-sm"
      />

      <div className="flex gap-4 items-center mb-4 flex-wrap">
        <label className="flex items-center gap-2">
          <span className="text-sm">Similarity:</span>
          <input
            type="range"
            min="0.3"
            max="0.9"
            step="0.05"
            value={threshold}
            onChange={(e) => setThreshold(parseFloat(e.target.value))}
            className="w-32"
          />
          <span className="text-sm font-mono">{threshold.toFixed(2)}</span>
        </label>
        
        <button
          onClick={visualize}
          disabled={loading}
          className="px-6 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 rounded font-semibold transition"
        >
          {loading ? 'Processing...' : 'Visualize'}
        </button>

        {status && (
          <span className="text-sm text-green-400">{status}</span>
        )}
      </div>

      <div className="bg-gray-800 rounded-lg p-4 border border-gray-700">
        <svg ref={svgRef} className="w-full"></svg>
      </div>

      <div className="mt-4 text-sm text-gray-400 space-y-2">
        <p className="text-green-400 font-semibold">ðŸš€ Powered by Transformers.js</p>
        <div className="grid grid-cols-2 gap-2">
          <div>
            <p className="font-semibold text-gray-300">Features:</p>
            <ul className="list-disc list-inside text-xs">
              <li>Real semantic embeddings (384-dim vectors)</li>
              <li>No API required - runs offline</li>
              <li>Model: all-MiniLM-L6-v2</li>
              <li>Drag nodes to explore</li>
            </ul>
          </div>
          <div>
            <p className="font-semibold text-gray-300">Tips:</p>
            <ul className="list-disc list-inside text-xs">
              <li>First load: downloads model (~23MB)</li>
              <li>After that: instant & cached</li>
              <li>Works with any language</li>
              <li>Higher threshold = fewer connections</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
}
